
@[TOC](    选择排序   )
## 简单选择排序
><font color=black>  选择排序属于内部排序法, 是从想要排序的数据中, 按指定的规则选出某一个元素, 再依规定的交换位置后达到排序的目的
 </font>

选择排序（select sorting）也是一种简单的排序方法。它的基本思想是：
第一次从arr[0]~arr[n-1]中选取最小值，与arr[0]交换，
第二次从arr[1]~arr[n-1]中选取最小值，与arr[1]交换，
第三次从arr[2]~arr[n-1]中选取最小值，与arr[2]交换，…，
第i次从arr[i-1]~arr[n-1]中选取最小值，与arr[i-1]交换，…, 
第n-1次从arr[n-2]~arr[n-1]中选取最小值，与arr[n-2]交换，总共通过n-1次，得到一个按排序码从小到大排列的有序序列。

思路图解
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200206171741346.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzcxNTU2,size_16,color_FFFFFF,t_70)

**实现代码**
- 执行数组长度-1次大循环, 每次循环的目的是将最小的元素放到当前数组最小值的位置
- 需要两个辅助变量, 最小元素min 和最小元素的下标 i
- 每次大循环执行一个小循环, 从i+1, 作用是比较当前位置相邻两个元素大小, 根据情况重置相关元素
- 每个大循环的结束时, 需要根据情况交换元素

```java
/**
 * 选择排序(正序)-时间复杂度 O(n^2)
 *
 * @author TimePause
 * @create 2020-02-01 11:39
 */
public class SelectSort {
    public static void main(String[] args) {
        int arr[] = {101, 34, 119, 1};
        selectSort(arr);
        System.out.println(Arrays.toString(arr));

    }

    public static void  selectSort(int arr[]){
        for (int i=0;i<arr.length-1;i++){
            // 定义最小的元素的下标
            int minIndex=i;
            // 定义最小元素
            int min = arr[i];
            for (int j=i+1;j<arr.length;j++){
                //将当前最小元素和arr[j]比较,如果大于arr[j]则重置
                if (min>arr[j]){
                    min = arr[j];//重置最小元素
                    minIndex = j;//重置最小元素下标
                }
            }
            // 将最小值, 放在arr[i],作用是交换元素. 然后执行下一次大循环
            if (minIndex!=i){
                arr[minIndex] = arr[i];
                arr[i]=min;
            }
           /* System.out.println("第"+(i+1)+"次排排结果");
            System.out.println(Arrays.toString(arr));*/
        }

    }
}

```






## 堆排序
>堆排序是基于二叉树实现的, 因此在学习堆排序时, 最好先学习一下树这种结构结构

- 堆排序是利用堆这种数据结构而设计的一种排序算法，**堆排序是一种选择排序**，它的**最坏，最好，平均时间复杂度均为O(nlogn)**，它也是**不稳定排序**。

- 堆是具有以下性质的完全二叉树：**每个结点的值都大于或等于其左右孩子结点的值，称为大顶堆, 注意 : 没有要求结点的左孩子的值和右孩子的值的大小关系。**

- 每个结点的值都小于或等于其左右孩子结点的值，称为小顶堆

**大顶堆举例说明**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216122324710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzcxNTU2,size_16,color_FFFFFF,t_70)

**小顶堆举例说明**
>小顶堆：arr[i] <= arr[2*i+1] && arr[i] <= arr[2*i+2] // i 对应第几个节点，i从0开始编号
>
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216122503747.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzcxNTU2,size_16,color_FFFFFF,t_70)


**堆排序基本思想**


- 将待排序序列构造成一个大顶堆
此时，整个序列的最大值就是堆顶的根节点。
- 将其与末尾元素进行交换，此时末尾就为最大值。
- 然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。

**可以看到在构建大顶堆的过程中，元素的个数逐渐减少，最后就得到一个有序序列了.**




<font color=red>  要求：给你一个数组 {4,6,8,5,9} , 要求使用堆排序法，将数组升序排序。  </font>
**图解**

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200216122126992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzMzcxNTU2,size_16,color_FFFFFF,t_70)
**代码实现**

```java
/**
 * 堆排序(升序)实现
 *
 * @author TimePause
 * @create 2020-02-16 12:12
 */
public class HeapSort {
    public static void main(String[] args) {
        //要求将数组进行升序排序
        int arr[] = {4, 6, 8, 5, 9};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
   /*     // 创建要给80000个的随机的数组
        int[] arr = new int[8000000];
        for (int i = 0; i < 8000000; i++) {
            arr[i] = (int) (Math.random() * 8000000); // 生成一个[0, 8000000) 数
        }

        System.out.println("排序前");
        Date data1 = new Date();
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        String date1Str = simpleDateFormat.format(data1);
        System.out.println("排序前的时间是=" + date1Str);

        heapSort(arr);

        Date data2 = new Date();
        String date2Str = simpleDateFormat.format(data2);
        System.out.println("排序前的时间是=" + date2Str);
        //System.out.println("排序后=" + Arrays.toString(arr));*/
    }

    //编写一个堆排序的方法
    public static void heapSort(int arr[]) {
        int temp = 0;
        System.out.println("执行堆排序操作!");
//		//分步完成
//		adjustHeap(arr, 1, arr.length);
//		System.out.println("第一次" + Arrays.toString(arr)); // 4, 9, 8, 5, 6
//
//		adjustHeap(arr, 0, arr.length);
//		System.out.println("第二次" + Arrays.toString(arr)); // 9,6,8,5,4

        //完成我们最终代码
        //1)将无序序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆
        for(int i = arr.length / 2 -1; i >=0; i--) {
            adjustHeap(arr, i, arr.length);
        }

		/*
		 * 2).将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
　　	   3).重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
		 */
        for(int j = arr.length-1;j >0; j--) {
            //交换
            temp = arr[j];
            arr[j] = arr[0];
            arr[0] = temp;
            adjustHeap(arr, 0, j);
        }

        //System.out.println("数组=" + Arrays.toString(arr));

    }

    /**
     * 将一个数组(二叉树), 调整成一个大顶堆
     * 功能： 完成 将 以 i 对应的非叶子结点的树调整成大顶堆
     * 举例  int arr[] = {4, 6, 8, 5, 9}; => i = 1 => adjustHeap => 得到 {4, 9, 8, 5, 6}
     * 如果我们再次调用  adjustHeap 传入的是 i = 0 => 得到 {4, 9, 8, 5, 6} => {9,6,8,5, 4}
     * @param arr 待调整的数组
     * @param i 非叶子结点在数组中索引
     * @param length 对多少个元素继续调整， length 是在逐渐的减少
     */
    public  static void adjustHeap(int arr[], int i, int length) {

        int temp = arr[i];//先取出当前元素的值，保存在临时变量
        //开始调整
        //1. k = i * 2 + 1 k 是 i结点的左子结点
        for(int k = i * 2 + 1; k < length; k = k * 2 + 1) {
            if(k+1 < length && arr[k] < arr[k+1]) { //说明左子结点的值小于右子结点的值
                k++; // k 指向右子结点
            }
            if(arr[k] > temp) { //如果子结点大于父结点
                arr[i] = arr[k]; //把较大的值赋给当前结点
                i = k; //!!! i 指向 k,继续循环比较
            } else {
                break;//!
            }
        }
        //当for 循环结束后，我们已经将以i 为父结点的树的最大值，放在了最顶(局部)
        arr[i] = temp;//将temp值放到调整后的位置
    }

}

```
>堆排序处理800w数据用时3-4秒左右, 可以看出, 堆排序效率也是比较高的
